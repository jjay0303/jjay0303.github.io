I"<h3 id="1-data_structure-스택stack-큐queue-트리tree-힙heap-자료구조에-대해-설명해주세요">1. [DATA_STRUCTURE] 스택(Stack), 큐(Queue), 트리(Tree), 힙(Heap) 자료구조에 대해 설명해주세요</h3>
<ol>
  <li>스택(stack)
    <ul>
      <li>선형 자료구조 중 하나로 LIFO(Last in First out) 구조</li>
      <li>자바에서 Stack 클래스를 구현하여 제공</li>
      <li>연산
        <ul>
          <li>삽입(push()) : 가장 윗부분에 항목 추가</li>
          <li>삭제(pop()) : 가장 윗부분 항목을 제거</li>
          <li>읽기(peek()) : 가장 윗부분 항목을 반환</li>
        </ul>
      </li>
      <li>활용 : 재귀함수, 방문기록(뒤로가기), 실행취소(undo) <br />
 <br /></li>
    </ul>
  </li>
  <li>큐(Queue)
    <ul>
      <li>선형 자료구조 중 하나로 LILO(Last in Last out) 구조</li>
      <li>자바에서 Queue인터페이스로만 정의</li>
      <li>연산
        <ul>
          <li>삽입(Enqueqe) : 맨 뒤에 요소 추가 / add() 또는 offer()</li>
          <li>삭제(Dequeue) : 맨 앞의 값을 삭제 / remove() 또는 poll()</li>
          <li>읽기 : 맨앞의 값을 삭제 없이 읽음 / element() 또는 peek()</li>
          <li>각 메소드들의 차이점</li>
        </ul>

        <table>
          <thead>
            <tr>
              <th style="text-align: center">연산종류</th>
              <th style="text-align: center">예외발생</th>
              <th style="text-align: center">값 리턴</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">삽입</td>
              <td style="text-align: center">add(o) : 저장공간 없으면 IllegalStateException</td>
              <td style="text-align: center">offer(o) : 실패시 false</td>
            </tr>
            <tr>
              <td style="text-align: center">삭제</td>
              <td style="text-align: center">remove() : 비어있으면 NoSuchElementException</td>
              <td style="text-align: center">poll() : 비어있으면 null</td>
            </tr>
            <tr>
              <td style="text-align: center">읽기</td>
              <td style="text-align: center">element() : 비어있으면 NoSuchElementException</td>
              <td style="text-align: center">peek() : 비어있으면 null</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>트리(Tree)
    <ul>
      <li>계층형 자료구조로 노드와 간선으로 이루어져있음</li>
      <li>최상단에 루트노드 한개에서 0개 이상의 자식노드를 가지며 각 노드를 잇는 길은 하나분이다. (즉, 사이클 존재 X)</li>
      <li>순회방법
        <ul>
          <li>전위(Pre-Order)</li>
          <li>중위(In-Order)</li>
          <li>후위(Post-Order)</li>
        </ul>
      </li>
      <li>종류 : 이진, 이진탐색, 균형, 완전이진, 포화이진 등..
 <br /><br /></li>
    </ul>
  </li>
  <li>힙(Heap)
    <ul>
      <li>완전 이진트리 중 하나로 여러 값들 중 최대값이나 최소값을 빠르게 찾아낼 수 있는 구조</li>
      <li>루트노드를 제외하고 반정렬 상태</li>
      <li>종류
        <ul>
          <li>최대힙 : 부모노드가 자식노드보다 항상 큼</li>
          <li>최소힙 : 부모노드가 자식노드보다 항상 작음</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="2-java-java의-string과-stringbuilder의-차이에-대해-설명하고-언제-stringbuilder를-사용하면-좋을지-얘기해주세요">2. [JAVA] Java의 String과 StringBuilder의 차이에 대해 설명하고 언제 StringBuilder를 사용하면 좋을지 얘기해주세요</h3>
<ol>
  <li>String
    <ul>
      <li>한번 생서되면 메모리 공간이 불변(Immutable)</li>
      <li>Heap 영역에 생성해서 기존 문자열 변경시 한번 생성된 객체의 내부 내용을 변화시키는 것이 아니라 새 String 객체에 변경된 문자열 저장 후 그 객체를 참조하고 이전 객체는 가비지 컬렉션이 제거함
👉 문자열 연산이 많을 경우 성능 떨어짐
👉 멀티쓰레드 환경에서는 고려할 것이 많이 없어 편리</li>
    </ul>
  </li>
  <li>StringBuilder
    <ul>
      <li>버퍼의 크기가 가변적(mutable)</li>
      <li>
        <p>크기를 설정하여 생성한 뒤 내부 Buffer에 문자열을 저장해두고 연산이 필요하면 크기를 변경하여 문자열을 변경함 
👉 문자열 연산시 String보다 속도가 빠르고 효율이 좋음
👉 단 생성 속도가 String보다 느림</p>
      </li>
      <li>StringBuilder와 StringBuffer의 차이
        <ul>
          <li>StringBuilder : 쓰레드 동기화 보장 X</li>
          <li>StringBuffer : 쓰레드 동기화 보장 O</li>
          <li>기능은 완전 똑같음</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>👉👉 문자열 연산이 자주 발생하거나 동기화를 고려하지 않는 환경에서는 StringBuilder 사용이 좋음</p>

<h3 id="3-java-가비지-컬렉션-알고리즘의-종류에-대해-설명해주세요">3. [JAVA] 가비지 컬렉션 알고리즘의 종류에 대해 설명해주세요</h3>
<ul>
  <li>
    <dl>
      <dt>가비지 컬렉션이란?</dt>
      <dd>프로그램 개발 시 유효하지 않은 메모리(가비지)가 발생하는데 이런 불필요한 메모리를 알아서 정리해주는 JVM의 컬렉터</dd>
    </dl>
  </li>
</ul>

<ol>
  <li>
    <dl>
      <dt>Serial GC</dt>
      <dd>Young 영역에서는 Mark Sweep으로, Old 영역에서는 Mark Sweep Compact 알고리즘을 사용. 모든 가비지 컬렉션 일을 처리하기 위해 1개의 쓰레드만 이용하므로 CPU 코어가 여러 개인 운영 서버에는 비적합</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>Parallel GC(Throughput GC)</dt>
      <dd>기본적으로 Serial GC와 동일하나 여러개의 쓰레드를 통해 GC를 수행</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>CMS(Concurrent Mark Sweep) GC</dt>
      <dd>여러개의 쓰레드를 이용하면서 Mark Sweep 알고리즘을 Concurrent하게 수행함 =&gt; 애플리케이션 지연 시간 최소화를 위해 고안되었으나 메모리와 CPU가 더 많이 필요</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>G1(Garbage First) GC</dt>
      <dd>CMS GC의 대체로 Heap을 동일한 크기의 Region(지역)으로 나누고, 가비지가 많은 지역에 우선적으로 GC를 수행</dd>
    </dl>
    <ul>
      <li>Minor GC</li>
      <li>Major GC(Full GC) : Java9부터 기본 가비지컬렉터로 사용</li>
    </ul>
  </li>
</ol>

<h4 id="참고">참고</h4>
<ul>
  <li>자바의정석</li>
  <li><a href="https://hidelookit.tistory.com/157">[자료구조] 스택, 큐, 힙</a></li>
  <li><a href="https://goodteacher.tistory.com/112">자료구조</a></li>
  <li><a href="https://mangkyu.tistory.com/119">망나니개발자</a></li>
</ul>
:ET